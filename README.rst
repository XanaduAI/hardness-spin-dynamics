The hardness of quantum spin dynamics
=====================================


This repository contains code to reproduce the anticoncentration results in the paper Park, Casares, Arrazola, and Huh: "The hardness of quantum spin dynamics."
The paper presents the anticoncentration property for the dynamics generated by the XX and the Ising Hamiltonians. This repository provides the C++ and Python codes used to obtain those results.

Build and Compile
-----------------

The repository contains C++ and Python code, with proper Python binding for some C++ functions. We recommend using a Python virtual environment to run our code. After cloning the repository, one can use the following commands to install the Python binding.

.. code-block:: bash

   $ python3 -m venv env        # create virtual env
   $ source ./env/bin/activate  # activate virtual env
   $ pip install .              # install Python binding


For building C++ code, the following commands should work. We note that `Eigen <https://eigen.tuxfamily.org/index.php?title=Main_Page>`_ and `OpenBLAS <https://www.openblas.net/>`_ are required to compile to code. A compiler with proper C++20 support (e.g., GCC >= 10) is also required to compile the code correctly.

.. code-block:: bash

   $ mkdir Build && cd Build
   $ cmake ..
   $ make

See also `Kokkos compile guide <https://kokkos.github.io/kokkos-core-wiki/ProgrammingGuide/Compiling.html>`_ for supported backends.


The XX model
------------

For $n < 10$, where $n$ is the number of spins in each part of the bipartite graph, we fully diagonalize the Hamiltonian to obtain the time evolution of the output probability, $p(x;J;t)$. For this purpose, two relevant source files, ``src/xx_time_evol_exact.cpp`` and ``python_src/xx_time_evol_exact.py`` are used.
The C++ code ``src/xx_time_evol_exact.cpp`` diagonalizes the constructed Hamiltonian using Eigen, whereas Python code ``python_src/xx_time_evol_exact.py`` utilizes JAX. Thus, our Python code is GPU enabled, which is significantly faster for larger $n$.


For $n = 10$, we implemented the time evolution using the second-order Trotter decomposition in ``src/xx_time_evol_trotter.cpp``. Our code is based on `PennyLane-Lightning-Kokkos <https://github.com/PennyLaneAI/pennylane-lightning>`_. We ran our code using NVidia A100, compiled with the CUDA backend of Kokkos.


For computing the output probability at times multiples of log of $n$, ``src/xx_at_log_time_trotter.cpp`` is used.


The Ising model
---------------

For the Ising model, the dynamics can be simulated solely by the `IsingXX <https://docs.pennylane.ai/en/stable/code/api/pennylane.IsingXX.html?highlight=isingxx#pennylane.IsingXX>`_ gates. C++ source code ``src/ising_time_evol.cpp`` and ``src/ising_at_log_time.cpp`` are used for the time evolution and for recording the output distribution at specific times, respectively.
